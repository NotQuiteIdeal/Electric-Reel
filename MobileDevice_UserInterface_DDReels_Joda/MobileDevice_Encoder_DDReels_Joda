/*
 * ----------------------------------------------------
 * DDReels Mobile Device - Rotary Encoder with Interrupts
 * Project: Dynamic Drag Reels (D.D. Reels)
 * Author: Gabriel Joda
 * Platform: Raspberry Pi Pico W
 * Purpose: Implements fully functional rotary encoder navigation.
 *
 *          Key Features:
 *            - Uses **hardware interrupts** for real-time encoder tracking.
 *            - Accurately detects **clockwise** and **counter-clockwise** rotations.
 *            - Efficient **menu index handling** (prevents overflow/underflow).
 *            - Non-blocking **interrupt-driven** implementation for minimal CPU load.
 *            - Easily expandable for additional button-based interactions.
 *
 *          Status: âœ… Fully functional - Stable and production-ready.
 * ----------------------------------------------------
 */

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// === Rotary Encoder Pin Definitions === //
#define ENCODER_A 10  // Encoder Channel A (Interrupt-driven)
#define ENCODER_B 11  // Encoder Channel B (Interrupt-driven)
#define ENCODER_BTN 12  // Encoder push-button (Active LOW)

// Global variables
volatile int menu_index = 0;  // Tracks the menu selection index
volatile bool cw_fall = false;  // Tracks clockwise movement
volatile bool ccw_fall = false;  // Tracks counter-clockwise movement

/*
 * Interrupt callback function for rotary encoder.
 * Detects the direction of rotation and updates `menu_index` accordingly.
 */
void encoder_callback(uint gpio, uint32_t events) {
    uint32_t gpio_state = (gpio_get_all() >> 10) & 0b11;  // Read only ENCODER_A and ENCODER_B

    if (gpio == ENCODER_A) {  // Detect changes on Channel A
        if (!cw_fall && (gpio_state == 0b10)) {
            cw_fall = true;  // Clockwise movement started
        }
        if (ccw_fall && (gpio_state == 0b00)) {  // Counter-clockwise detected
            ccw_fall = false;
            cw_fall = false;
            menu_index--;
            if (menu_index < 0) menu_index = 0;  // Prevent underflow
            printf("[ENCODER] Counter-clockwise - Menu index: %d\n", menu_index);
        }
    } else if (gpio == ENCODER_B) {  // Detect changes on Channel B
        if (!ccw_fall && (gpio_state == 0b01)) {
            ccw_fall = true;  // Counter-clockwise movement started
        }
        if (cw_fall && (gpio_state == 0b00)) {  // Clockwise detected
            cw_fall = false;
            ccw_fall = false;
            menu_index++;
            if (menu_index > 4) menu_index = 4;  // Prevent overflow
            printf("[ENCODER] Clockwise - Menu index: %d\n", menu_index);
        }
    }
}

/*
 * Initializes GPIOs for rotary encoder.
 * Configures encoder pins as inputs and enables interrupts.
 */
void gpio_setup() {
    // Configure encoder channels as inputs with pull-ups
    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_up(ENCODER_A);

    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_up(ENCODER_B);

    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_up(ENCODER_BTN);

    // Attach interrupt handlers
    gpio_set_irq_enabled_with_callback(ENCODER_A, GPIO_IRQ_EDGE_FALL, true, &encoder_callback);
    gpio_set_irq_enabled(ENCODER_B, GPIO_IRQ_EDGE_FALL, true);
}

/*
 * Main function - Initializes system and runs the main loop.
 */
int main() {
    stdio_init_all();
    sleep_ms(2000);  // Delay for serial connection stability
    printf("[SYSTEM] Starting...\n");

    gpio_setup();  // Initialize encoder GPIOs

    while (1) {
        sleep_ms(100);  // Main loop continues while interrupts handle the encoder
    }
}
