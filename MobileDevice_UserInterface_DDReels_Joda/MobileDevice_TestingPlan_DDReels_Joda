/*
 * ----------------------------------------------------------------------
 * DDReels Mobile Device - Encoder-Based Settings Navigation with UI
 * Project: Dynamic Drag Reels (D.D. Reels)
 * Author: Gabriel Joda
 * Platform: Raspberry Pi Pico W
 * Purpose: Implements rotary encoder-driven settings navigation and adjustments.
 *
 *          Key Features:
 *            - **Rotary encoder controls menu selection** with real-time updates.
 *            - **Debounce logic** ensures **glitch-free movement and selection.**
 *            - **Long press detection** allows seamless entry/exit of settings.
 *            - **Submenus enable fine-tuned adjustments** for key parameters:
 *                 - Reel-Up Speed (%)
 *                 - Auto Stop Length (ft)
 *                 - Metric/Imperial mode toggle
 *                 - Alarm On/Off toggle
 *                 - Save settings
 *            - **LCD updates only when necessary** to optimize efficiency.
 *            - **LED and button feedback system** for better user interaction.
 *            - **Expandable framework** to support future feature integration.
 *
 *          Status: âœ… Fully functional - Ready for testing.
 * ----------------------------------------------------------------------
 */

#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// === LCD Pin Definitions === //
// The LCD module (4x20 display) uses a controller similar to the HD44780,
// but our module is built around the RW1073 driver/controller. For pin details and initialization,
// see MobileDevice_LCD_Joda.pdf :contentReference[oaicite:4]{index=4} and RW1073 datasheet :contentReference[oaicite:5]{index=5}.
#define PIN_RS  17    // Register Select pin; low for command, high for data.
#define PIN_RW  19    // Read/Write control; low for write.
#define PIN_E   18    // Enable pin: triggers data read/write on falling edge.
#define PIN_RES 20    // Reset pin for the LCD module.

// 8-bit Data Bus for LCD
// Data lines D0-D7 are assigned to these GPIO pins.
const int data_pins[8] = {16, 3, 4, 5, 6, 7, 8, 9};

// Rotary Encoder Pins
// Using a Bourns PEC11 encoder (see MobileDevice_Encoder_Joda.pdf :contentReference[oaicite:6]{index=6}).
#define ENCODER_A   10  // Channel A of the rotary encoder.
#define ENCODER_B   11  // Channel B of the rotary encoder.
#define ENCODER_BTN 12  // Integrated push-button on the encoder.

// Button and LED Pins
// These buttons/LEDs serve various functions (e.g., fish bitting simulator, mute, Reel-Up).
#define BUTTON_26 26 // Fish bitting simulator button.
#define BUTTON_14 14 // Mute button.
#define BUTTON_15 15 // Reel-Up button.
#define LED_28    28 // Alarm LED.
#define LED_13    13 // Alarm buzzer.
#define LED_27    27 // Reel-Up LED indicator.

// Global Variables
volatile int menu_index = 0;        // Current menu selection index.
volatile bool in_settings_menu = false; // Flag: if settings menu is active.
volatile uint32_t button_press_time = 0; // Timestamp for button press duration.
volatile bool button_pressed = false;      // Flag for encoder button pressed.

// These flags help with debouncing the rotary encoder signals in the ISR.
volatile bool cw_fall = false;  // Set when a falling edge on channel A is detected.
volatile bool ccw_fall = false; // Set when a falling edge on channel B is detected.

// For LCD refresh in main loop: track last displayed menu index.
int last_menu_index = -1;

// New global flag: when entering settings mode, ignore the very next encoder button press.
volatile bool ignore_next_press = false;

// New flag for when a subpage is active (i.e., editing a specific setting).
volatile bool in_submenu = false;

// Global parameter variables (user-adjustable settings)
// These values are used in subpages for adjusting reel speed, stop length, etc.
int reel_speed = 50;       // Reel-Up speed percentage (0 to 100%), in steps of 10.
int stop_length = 10;      // Auto stop length in feet (0 to 100 FT), in steps of 1.
bool metric_mode = false;  // Display mode: false = Imperial, true = Metric.
bool alarm_enabled = true; // Alarm enabled flag (used to drive LED_28 and LED_13).

// --- LCD Helper Functions --- //
// Writes an 8-bit value to the LCD data bus by setting each data pin.
void lcd_write_bus(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        gpio_put(data_pins[i], (data >> i) & 1);
    }
}

// Generates an enable pulse (as required by the LCD controller per RW1073 and HD44780 protocols :contentReference[oaicite:8]{index=8}).
void lcd_pulse_enable() {
    gpio_put(PIN_E, 1);
    sleep_us(200);
    gpio_put(PIN_E, 0);
    sleep_us(200);
}

// Sends a command byte to the LCD.
void lcd_send_command(uint8_t cmd) {
    gpio_put(PIN_RS, 0); // RS low = command.
    gpio_put(PIN_RW, 0); // Write mode.
    lcd_write_bus(cmd);
    lcd_pulse_enable();
    sleep_ms(2); // Allow time for the command to process.
}

// Sends a data byte to the LCD.
void lcd_send_data(uint8_t data) {
    gpio_put(PIN_RS, 1); // RS high = data.
    gpio_put(PIN_RW, 0); // Write mode.
    lcd_write_bus(data);
    lcd_pulse_enable();
    sleep_ms(1);
}

// Initializes the LCD module.
// The initialization sequence is based on standard HD44780/RW1073 procedures :contentReference[oaicite:9]{index=9} and :contentReference[oaicite:10]{index=10}.
void lcd_init() {
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(200);

    lcd_send_command(0x30); // Function set: 8-bit interface.
    sleep_ms(10);
    lcd_send_command(0x06); // Entry mode set: auto-increment.
    sleep_ms(5);
    lcd_send_command(0x36); // Function set: extended mode, per RW1073.
    sleep_ms(10);
    lcd_send_command(0x09); // Function set: icon display on (if applicable).
    sleep_ms(5);
    lcd_send_command(0x30); // Function set: back to basic instruction set.
    sleep_ms(10);
    lcd_send_command(0x0C); // Display ON: display on, cursor off.
    sleep_ms(5);
    lcd_send_command(0x01); // Clear display.
    sleep_ms(10);

    printf("[LCD] Initialization Complete!\n");
}

// Prints a string to the LCD at the current cursor position.
void lcd_print(const char *str) {
    while (*str) {
        lcd_send_data(*str++);
    }
}

// Prints a string to the LCD at the current cursor position (starting at column 0 of the given line).
void lcd_print_normal(const char *str, uint8_t line) {
    uint8_t ddram_address = (line - 1) * 0x20;
    lcd_send_command(0x80 | ddram_address);
    lcd_print(str);
}

// Prints a string centered on a given line (1-4) on the LCD.
// Uses the 4x20 or similar display dimensions (as per MobileDevice_LCD_Joda :contentReference[oaicite:11]{index=11}).
void lcd_print_centered(const char *str, uint8_t line) {
    uint8_t start_pos = (20 - strlen(str)) / 2;
    uint8_t ddram_address = (line - 1) * 0x20 + start_pos;
    lcd_send_command(0x80 | ddram_address);
    lcd_print(str);
}

// Displays the main screen of the device.
// This screen might show primary operational information (e.g., reel position, etc.).
void display_main_screen() {
    lcd_send_command(0x01);  // Clear Display.
    lcd_print_centered("MAIN SCREEN", 1);
    lcd_print_centered("0005 FEET", 2);
    lcd_print_centered("05 FT LBS", 3);
    printf("[LCD] Main Screen Displayed.\n");
}

// Displays the settings menu.
// Each option is printed on one line; the selected option is indicated with a "<" cursor at the right edge.
void display_settings_menu(int index) {
    const char *menu_items[] = {
        "1.Reel-Up Speed",    // Adjust reel speed in %.
        "2.Auto Stop Length", // Adjust stop length in FT.
        "3.Metric/Imperial",  // Toggle display units.
        "4.Turn off Alarm",   // Enable/disable alarm.
        "5.Save Settings"     // Save the current settings.
    };

    int start_index = index >= 4 ? index - 3 : 0;

    lcd_send_command(0x01);  // Clear Display.
    for (int i = 0; i < 4; i++) {
        lcd_send_command(0x80 | (i * 0x20));  // Move to beginning of each line.
        if (start_index + i < 5) {
            lcd_print(menu_items[start_index + i]);
            if (start_index + i == index) {
                lcd_send_command(0x80 | ((i * 0x20) + 19));  // Print selection indicator at column 20.
                lcd_print("<");
            }
        }
    }
    printf("[LCD] Settings Menu Item: %s\n", menu_items[index % 5]);
}

// --- Subpage Functionality --- //
// Opens a subpage for the selected setting. For options 0-3, a subpage is used for editing.
// For option 5 ("Save Settings" corresponding to menu_index == 4), we immediately save without opening a subpage.
void open_subpage(int selection) {
    in_submenu = true;
    lcd_send_command(0x01); // Clear display.
    switch(selection) {
        case 0:
            lcd_print_centered("Reel-Up Speed", 1);
            lcd_print_centered("20%", 2);
            lcd_print_normal("Press to Return.", 4);
            break;
        case 1:
            lcd_print_centered("Auto Stop Length", 1);
            lcd_print_centered("5 FT", 2);
            lcd_print_normal("Press to Return.", 4);
            break;
        case 2:
            lcd_print_centered("Metric/Imperial", 1);
            lcd_print_centered("Current: Imperial", 2);
            lcd_print_normal("Press to Return.", 4);
            break;
        case 3:
            lcd_print_centered("Turn off Alarm", 1);
            lcd_print_centered("Current: Alarm On", 2);
            lcd_print_normal("Press to Return.", 4);
            break;
        case 4:
            // For Save Settings, we do not open a subpage.
            break;
        default:
            lcd_print_centered("Undefined", 1);
            break;
    }
    printf("[SUBPAGE] Opened subpage for selection %d\n", selection);
}

// --- Check Encoder Button in Settings/Subpage --- //
// When the encoder button is pressed in the settings menu, we check if it's a short press.
// If the current menu option is "Save Settings" (menu_index == 4), then a short press immediately saves
// and returns to the main screen. Otherwise, a short press opens the corresponding subpage.
void check_settings_selection(void) {
    static bool was_pressed = false;
    static uint32_t press_time = 0;
    bool current = !gpio_get(ENCODER_BTN); // Button active low.
    if (ignore_next_press) {
        if (gpio_get(ENCODER_BTN))
            ignore_next_press = false;
        return;
    }
    if (current && !was_pressed) {
        press_time = to_ms_since_boot(get_absolute_time());
        was_pressed = true;
    } else if (!current && was_pressed) {
        uint32_t duration = to_ms_since_boot(get_absolute_time()) - press_time;
        if (duration < 3000) {
            if (menu_index == 4) {
                // For "Save Settings", immediately save and return to main screen.
                printf("[SAVE] Settings saved: Speed=%d%%, Length=%dFT, Mode=%s, Alarm=%s\n",
                       reel_speed, stop_length,
                       metric_mode ? "Metric" : "Imperial",
                       alarm_enabled ? "ON" : "OFF");
                in_settings_menu = false;
                lcd_send_command(0x01);  // Clear Display.
                lcd_print_centered("Saving...", 2);
                sleep_ms(1000);
                display_main_screen();
                printf("[SAVE] Returned to main screen after saving.\n");
            } else {
                open_subpage(menu_index);
            }
        }
        was_pressed = false;
    }
}

// In a subpage for options 0-3, a short press on the encoder button returns to the settings menu.
void check_submenu_exit(void) {
    static bool was_pressed = false;
    static uint32_t press_time = 0;
    bool current = !gpio_get(ENCODER_BTN); // Active low.
    if (current && !was_pressed) {
        press_time = to_ms_since_boot(get_absolute_time());
        was_pressed = true;
    } else if (!current && was_pressed) {
        uint32_t duration = to_ms_since_boot(get_absolute_time()) - press_time;
        if (duration < 3000) {
            in_submenu = false;
            display_settings_menu(menu_index);
            last_menu_index = menu_index;
            printf("[SUBPAGE] Exiting subpage.\n");
        } else {
            in_submenu = false;
            display_settings_menu(menu_index);
            last_menu_index = menu_index;
            printf("[SUBPAGE] Exiting subpage via long press.\n");
        }
        was_pressed = false;
    }
}

// --- Rotary Encoder Interrupt Callback --- //
// When not in a subpage, encoder rotations update the settings menu selection.
// In a subpage for numeric options (menu_index 0 or 1), rotations adjust the parameter values.
void encoder_callback(uint gpio, uint32_t events) {
    uint32_t gpio_state = (gpio_get_all() >> 10) & 0b11;
    if (!in_submenu) {
        if (gpio == ENCODER_A) {
            if (!cw_fall && (gpio_state == 0b10)) {
                cw_fall = true;
            }
            if (ccw_fall && (gpio_state == 0b00)) {
                ccw_fall = false;
                cw_fall = false;
                menu_index--;
                if (menu_index < 0) menu_index = 0;
                printf("[ENCODER] CCW - Menu index: %d\n", menu_index);
            }
        } else if (gpio == ENCODER_B) {
            if (!ccw_fall && (gpio_state == 0b01)) {
                ccw_fall = true;
            }
            if (cw_fall && (gpio_state == 0b00)) {
                cw_fall = false;
                ccw_fall = false;
                menu_index++;
                if (menu_index > 4) menu_index = 4;
                printf("[ENCODER] CW - Menu index: %d\n", menu_index);
            }
        }
    } else {
        if (menu_index == 0 || menu_index == 1) {
            if (gpio == ENCODER_A) {
                if (!cw_fall && (gpio_state == 0b10)) {
                    cw_fall = true;
                }
                if (ccw_fall && (gpio_state == 0b00)) {
                    ccw_fall = false;
                    cw_fall = false;
                    if (menu_index == 0) {
                        reel_speed -= 10;
                        if (reel_speed < 0) reel_speed = 0;
                    } else if (menu_index == 1) {
                        stop_length -= 1;
                        if (stop_length < 0) stop_length = 0;
                    }
                    printf("[SUBPAGE] Updated (CCW) - ");
                    if (menu_index == 0)
                        printf("Speed: %d%%\n", reel_speed);
                    else
                        printf("Length: %d FT\n", stop_length);
                }
            } else if (gpio == ENCODER_B) {
                if (!ccw_fall && (gpio_state == 0b01)) {
                    ccw_fall = true;
                }
                if (cw_fall && (gpio_state == 0b00)) {
                    cw_fall = false;
                    ccw_fall = false;
                    if (menu_index == 0) {
                        reel_speed += 10;
                        if (reel_speed > 100) reel_speed = 100;
                    } else if (menu_index == 1) {
                        stop_length += 1;
                        if (stop_length > 100) stop_length = 100;
                    }
                    printf("[SUBPAGE] Updated (CW) - ");
                    if (menu_index == 0)
                        printf("Speed: %d%%\n", reel_speed);
                    else
                        printf("Length: %d FT\n", stop_length);
                }
            }
        }
        // For other subpages (options 2, 3, and 4), encoder rotations are not used.
    }
}

// --- Check Button for Long Press to Enter Settings --- //
// Outside of settings mode, a long press of the encoder button enters the settings menu.
void check_button_long_press(void) {
    if (!in_settings_menu && !gpio_get(ENCODER_BTN)) { // Button active low.
        if (!button_pressed) {
            button_pressed = true;
            button_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_press_time > 3000) {
            in_settings_menu = true;
            menu_index = 0;
            display_settings_menu(menu_index);
            last_menu_index = menu_index;
            ignore_next_press = true; // Prevent immediate subpage open.
            printf("[SETTINGS] Entering settings menu via long press.\n");
        }
    } else if (gpio_get(ENCODER_BTN)) {
        button_pressed = false;
    }
}

// --- Handle Other Buttons --- //
// Additional buttons (BUTTON_26, BUTTON_14, BUTTON_15) control other functions.
// For example, BUTTON_26 might simulate fish biting, BUTTON_14 mutes audio, etc.
// LED_28, LED_13, LED_27 indicate status (e.g., alarm, Reel-Up indicator).
void handle_buttons() {
    if (gpio_get(BUTTON_26)) {
        gpio_put(LED_28, 1);
        gpio_put(LED_13, 1);
    }
    if (gpio_get(BUTTON_14)) {
        gpio_put(LED_28, 0);
        gpio_put(LED_13, 0);
    }
    static uint32_t button_15_press_time = 0;
    static bool led_27_on = false;
    static bool button_15_released = true;
    if (gpio_get(BUTTON_15)) {
        if (button_15_press_time == 0 && button_15_released) {
            button_15_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_15_press_time > 3000 && !led_27_on) {
            gpio_put(LED_27, 1);  // Turn on LED_27 after 3 seconds.
            led_27_on = true;
            button_15_released = false;
        }
    } else {
        if (button_15_press_time > 0) {
            if (!led_27_on) {
                gpio_put(LED_27, 0);
            } else {
                led_27_on = false;
            }
            button_15_press_time = 0;
            button_15_released = true;
        }
    }
}

// --- GPIO Setup --- //
void gpio_setup(void) {
    int control_pins[] = {PIN_RS, PIN_RW, PIN_E, PIN_RES};
    for (int i = 0; i < 4; i++) {
        gpio_init(control_pins[i]);
        gpio_set_dir(control_pins[i], GPIO_OUT);
    }
    for (int i = 0; i < 8; i++) {
        gpio_init(data_pins[i]);
        gpio_set_dir(data_pins[i], GPIO_OUT);
    }
    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_up(ENCODER_A);
    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_up(ENCODER_B);
    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_up(ENCODER_BTN);
    // Set up encoder interrupts on both rising and falling edges for responsiveness.
    gpio_set_irq_enabled_with_callback(ENCODER_A, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &encoder_callback);
    gpio_set_irq_enabled(ENCODER_B, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);
    // Initialize additional buttons.
    gpio_init(BUTTON_26);
    gpio_set_dir(BUTTON_26, GPIO_IN);
    gpio_pull_down(BUTTON_26);
    gpio_init(BUTTON_14);
    gpio_set_dir(BUTTON_14, GPIO_IN);
    gpio_pull_down(BUTTON_14);
    gpio_init(BUTTON_15);
    gpio_set_dir(BUTTON_15, GPIO_IN);
    gpio_pull_down(BUTTON_15);
    // Initialize LED outputs.
    gpio_init(LED_28);
    gpio_set_dir(LED_28, GPIO_OUT);
    gpio_put(LED_28, 0);
    gpio_init(LED_13);
    gpio_set_dir(LED_13, GPIO_OUT);
    gpio_put(LED_13, 0);
    gpio_init(LED_27);
    gpio_set_dir(LED_27, GPIO_OUT);
    gpio_put(LED_27, 0);
}

int main(void) {
    stdio_init_all();
    sleep_ms(2000);
    printf("[SYSTEM] Starting...\n");
    gpio_setup();
    lcd_init();
    display_main_screen();
    while (1) {
        // Outside settings, check for a long press to enter settings menu.
        if (!in_settings_menu) {
            check_button_long_press();
        }
        // In settings mode: if in a subpage, check for exit; otherwise, check for subpage entry.
        if (in_settings_menu) {
            if (in_submenu) {
                check_submenu_exit();
            } else {
                check_settings_selection();
                if (menu_index != last_menu_index) {
                    display_settings_menu(menu_index);
                    last_menu_index = menu_index;
                }
            }
        }
        handle_buttons();
        sleep_ms(50);
    }
}
