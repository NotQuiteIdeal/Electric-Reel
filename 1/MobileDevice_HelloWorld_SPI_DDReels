/*
 * ----------------------------------------------------
 * DDReels Mobile Device - SPI LCD Communication
 * Project: Dynamic Drag Reels (D.D. Reels)
 * Author: Gabriel Joda
 * Platform: Raspberry Pi Pico W
 * Purpose: This is the third iteration of the SPI communication code for the EA DIP205-6 LCD (RW1073 Controller).
 *          This version introduces debugging output via `printf()` to monitor commands and data sent to the LCD.
 *
 *          The code initializes SPI communication, performs hardware reset, and attempts to write to the 4x20 character LCD.
 *          Like the previous iteration, it includes a busy flag check before sending commands to improve reliability.
 *
 *          However, **this iteration still does not work correctly**. Issues may be related to the SPI read operation used for the
 *          busy flag check or timing mismatches in command execution. Debugging output should help identify the issue.
 *
 * Status: This code does not work as intended. Debugging required.
 * ----------------------------------------------------
 */

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/spi.h"

// SPI Pins
#define SPI_PORT spi0
#define PIN_MISO 16  // SOD (Slave Out)
#define PIN_CS   17  // Chip Select
#define PIN_SCLK 18  // Clock
#define PIN_MOSI 19  // Data (SID)
#define PIN_RES  22  // Reset (active low)

// RW1073 Commands
#define CMD_CLEAR       0x01
#define CMD_HOME        0x02
#define CMD_ENTRY_MODE  0x06
#define CMD_DISPLAY_CTL 0x0C
#define CMD_FUNCTION    0x30
#define CMD_EXT_FUNCTION 0x36

// Busy Flag Check
bool lcd_is_busy() {
    uint8_t cmd = 0x00;  // Read BF + Address
    uint8_t response;
    
    gpio_put(PIN_CS, 0);
    spi_write_read_blocking(SPI_PORT, &cmd, &response, 1);
    gpio_put(PIN_CS, 1);
    
    return (response & 0x80);  // BF is bit 7
}

void lcd_wait() {
    while(lcd_is_busy()) { 
        sleep_us(100); 
    }
}

void lcd_command(uint8_t cmd) {
    lcd_wait();
    gpio_put(PIN_CS, 0);
    spi_write_blocking(SPI_PORT, &cmd, 1);
    gpio_put(PIN_CS, 1);
    printf("Command sent: 0x%02X\n", cmd);
}

void lcd_data(uint8_t data) {
    lcd_wait();
    gpio_put(PIN_CS, 0);
    uint8_t packet = data | 0x40;  // RS=1
    spi_write_blocking(SPI_PORT, &packet, 1);
    gpio_put(PIN_CS, 1);
    printf("Data sent: 0x%02X\n", data);
}

void lcd_init() {
    // Hardware Reset
    gpio_init(PIN_RES);
    gpio_set_dir(PIN_RES, GPIO_OUT);
    gpio_put(PIN_RES, 0);  // Active low reset
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(150);  // Wait >100ms after reset

    // SPI Configuration
    spi_init(SPI_PORT, 100000);  // 100kHz clock
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCLK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Initialization Sequence
    lcd_command(0x30);       // 8-bit mode
    sleep_ms(15);
    lcd_command(0x30);       // Repeat
    sleep_ms(5);
    lcd_command(0x30);       // Final init
    sleep_ms(1);
    
    lcd_command(CMD_EXT_FUNCTION | 0x04);  // 4-line mode
    lcd_command(0x09);        // 4-line + icons
    lcd_command(CMD_DISPLAY_CTL | 0x04);  // Display ON
    lcd_command(CMD_CLEAR);
    sleep_ms(5);
    lcd_command(CMD_ENTRY_MODE | 0x02);  // Auto-increment
}

int main() {
    stdio_init_all();
    printf("Initializing LCD...\n");

    lcd_init();
    printf("LCD Initialized.\n");

    // Write to all 4 lines
    lcd_command(0x80);  // Line 1
    lcd_data('H'); lcd_data('e'); lcd_data('l'); lcd_data('l'); lcd_data('o');
    
    lcd_command(0xA0);  // Line 2
    lcd_data('W'); lcd_data('o'); lcd_data('r'); lcd_data('l'); lcd_data('d');

    printf("Display updated.\n");

    while(1) tight_loop_contents();
}
