/*
 * ----------------------------------------------------
 * DDReels Mobile Device - SPI LCD Communication
 * Project: Dynamic Drag Reels (D.D. Reels)
 * Author: Gabriel Joda
 * Platform: Raspberry Pi Pico W
 * Purpose: This is the second iteration of the SPI communication code for the EA DIP205-6 LCD (RW1073 Controller).
 *          This version attempts to implement a busy flag check before sending commands to improve reliability.
 *
 *          The code initializes SPI communication, performs hardware reset, and attempts to write to the 4x20 character LCD.
 *          Unlike the first iteration, this version introduces `lcd_is_busy()` to check the RW1073 busy flag before executing
 *          new commands. However, due to potential SPI timing and read functionality issues, this iteration **still does not work correctly**.
 *
 *          Future iterations will address possible issues with SPI read operations and signal synchronization.
 *
 *
 * Status: This code does not work as intended. Debugging required.
 * ----------------------------------------------------
 */

#include <stdio.h>
#include "pico/stdlib.h"
#include "hardware/spi.h"

// SPI Pins
#define SPI_PORT spi0
#define PIN_MISO 16  // SOD ‚Üê MUST CONNECT
#define PIN_CS   17
#define PIN_SCLK 18
#define PIN_MOSI 19
#define PIN_RES  20

// RW1073 Commands
#define CMD_CLEAR       0x01
#define CMD_HOME        0x02
#define CMD_ENTRY_MODE  0x06
#define CMD_DISPLAY_CTL 0x0C
#define CMD_FUNCTION    0x30
#define CMD_EXT_FUNCTION 0x36

// Busy Flag Check
bool lcd_is_busy() {
    uint8_t cmd = 0x00;  // Read BF + Address
    uint8_t response;
    
    gpio_put(PIN_CS, 0);
    spi_write_read_blocking(SPI_PORT, &cmd, &response, 1);
    gpio_put(PIN_CS, 1);
    
    return (response & 0x80);  // BF is bit 7
}

void lcd_wait() {
    while(lcd_is_busy()) { 
        sleep_us(100); 
    }
}

void lcd_command(uint8_t cmd) {
    lcd_wait();
    gpio_put(PIN_CS, 0);
    spi_write_blocking(SPI_PORT, &cmd, 1);
    gpio_put(PIN_CS, 1);
}

void lcd_data(uint8_t data) {
    lcd_wait();
    gpio_put(PIN_CS, 0);
    uint8_t packet = data | 0x40;  // RS=1
    spi_write_blocking(SPI_PORT, &packet, 1);
    gpio_put(PIN_CS, 1);
}

void lcd_init() {
    // Hardware Reset
    gpio_init(PIN_RES);
    gpio_set_dir(PIN_RES, GPIO_OUT);
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(150);

    // SPI Configuration
    spi_init(SPI_PORT, 100000);  // 100kHz
    gpio_set_function(PIN_MISO, GPIO_FUNC_SPI);
    gpio_set_function(PIN_SCLK, GPIO_FUNC_SPI);
    gpio_set_function(PIN_MOSI, GPIO_FUNC_SPI);

    // Initialization Sequence
    lcd_command(0x30);       // 8-bit mode
    sleep_ms(15);
    lcd_command(0x30);       // Repeat
    sleep_ms(5);
    lcd_command(0x30);       // Final init
    sleep_ms(1);
    
    lcd_command(CMD_EXT_FUNCTION | 0x04);  // 4-line mode
    lcd_command(0x09);        // 4-line + icons
    lcd_command(CMD_DISPLAY_CTL | 0x04);  // Display ON
    lcd_command(CMD_CLEAR);
    sleep_ms(5);
    lcd_command(CMD_ENTRY_MODE | 0x02);  // Auto-increment
}

int main() {
    stdio_init_all();
    lcd_init();

    // Write to all 4 lines
    lcd_command(0x80);  // Line 1
    lcd_data('H'); lcd_data('e'); lcd_data('l'); lcd_data('l'); lcd_data('o');
    
    lcd_command(0xA0);  // Line 2
    lcd_data('W'); lcd_data('o'); lcd_data('r'); lcd_data('l'); lcd_data('d');

    while(1) tight_loop_contents();
}
