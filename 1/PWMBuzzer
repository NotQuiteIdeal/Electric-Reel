#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"
#include "hardware/pwm.h"

// === LCD Pin Definitions === //
#define PIN_RS  17  
#define PIN_RW  19  
#define PIN_E   18  
#define PIN_RES 20  

// 8-bit Data Bus
const int data_pins[8] = {16, 3, 4, 5, 6, 7, 8, 9};

// Rotary Encoder Pins
#define ENCODER_A 10  
#define ENCODER_B 11  
#define ENCODER_BTN 12  

// Button and LED Pins
#define BUTTON_26 26
#define BUTTON_14 14
#define BUTTON_15 15
#define LED_28 28
#define LED_27 27
#define BUZZER 13  // Buzzer on GPIO 13

// Global Variables
volatile int menu_index = 0;
volatile bool in_settings_menu = false;
volatile uint32_t button_press_time = 0;
volatile bool button_pressed = false;
volatile int last_A = 0;
volatile int last_B = 0;
#define DEBOUNCE_DELAY_US 1000  // 1 ms debounce delay

void gpio_setup() {
    int control_pins[] = {PIN_RS, PIN_RW, PIN_E, PIN_RES};
    for (int i = 0; i < 4; i++) {
        gpio_init(control_pins[i]);
        gpio_set_dir(control_pins[i], GPIO_OUT);
    }

    for (int i = 0; i < 8; i++) {
        gpio_init(data_pins[i]);
        gpio_set_dir(data_pins[i], GPIO_OUT);
    }

    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_down(ENCODER_A);

    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_down(ENCODER_B);

    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_down(ENCODER_BTN);

    // Button and LED setup
    gpio_init(BUTTON_26);
    gpio_set_dir(BUTTON_26, GPIO_IN);
    gpio_pull_down(BUTTON_26);

    gpio_init(BUTTON_14);
    gpio_set_dir(BUTTON_14, GPIO_IN);
    gpio_pull_down(BUTTON_14);

    gpio_init(BUTTON_15);
    gpio_set_dir(BUTTON_15, GPIO_IN);
    gpio_pull_down(BUTTON_15);

    gpio_init(LED_28);
    gpio_set_dir(LED_28, GPIO_OUT);
    gpio_put(LED_28, 0);

    gpio_init(LED_27);
    gpio_set_dir(LED_27, GPIO_OUT);
    gpio_put(LED_27, 0);

    // Buzzer setup (PWM on GPIO 13)
    gpio_set_function(BUZZER, GPIO_FUNC_PWM);
    uint slice_num = pwm_gpio_to_slice_num(BUZZER);
    pwm_set_wrap(slice_num, 255);
    pwm_set_enabled(slice_num, true);

    last_A = gpio_get(ENCODER_A);
    last_B = gpio_get(ENCODER_B);
}

void set_buzzer_frequency(uint16_t freq) {
    uint slice_num = pwm_gpio_to_slice_num(BUZZER);
    uint32_t clock_freq = 125000000;  // Default clock frequency in Hz
    uint32_t divider = clock_freq / (256 * freq);
    pwm_set_clkdiv(slice_num, divider);
    pwm_set_gpio_level(BUZZER, 128);  // 50% duty cycle for the buzzer
}

void stop_buzzer() {
    pwm_set_gpio_level(BUZZER, 0);
}

void play_cool_buzzer_sound() {
    uint16_t frequencies[] = {262, 294, 330, 349, 392, 440, 494, 523};  // C, D, E, F, G, A, B, C
    for (int i = 0; i < 8; i++) {
        set_buzzer_frequency(frequencies[i]);
        sleep_ms(200);
    }
    stop_buzzer();
}

// === LCD Helper Functions === //
void lcd_write_bus(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        gpio_put(data_pins[i], (data >> i) & 1);
    }
}

void lcd_pulse_enable() {
    gpio_put(PIN_E, 1);
    sleep_us(200);
    gpio_put(PIN_E, 0);
    sleep_us(200);
}

void lcd_send_command(uint8_t cmd) {
    gpio_put(PIN_RS, 0);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(cmd);
    lcd_pulse_enable();
    sleep_ms(2);
}

void lcd_send_data(uint8_t data) {
    gpio_put(PIN_RS, 1);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(data);
    lcd_pulse_enable();
    sleep_ms(1);
}

void lcd_init() {
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(200);

    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x06);
    sleep_ms(5);
    lcd_send_command(0x36);
    sleep_ms(10);
    lcd_send_command(0x09);
    sleep_ms(5);
    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x0C);
    sleep_ms(5);
    lcd_send_command(0x01);
    sleep_ms(10);

    printf("[LCD] Initialization Complete!\n");
}

void lcd_print_centered(const char *str, uint8_t line) {
    uint8_t start_pos = (20 - strlen(str)) / 2;
    uint8_t ddram_address = 0x00;

    switch (line) {
        case 1: ddram_address = 0x00 + start_pos; break;
        case 2: ddram_address = 0x20 + start_pos; break;
        case 3: ddram_address = 0x40 + start_pos; break;
        case 4: ddram_address = 0x60 + start_pos; break;
    }

    lcd_send_command(0x80 | ddram_address);
    while (*str) lcd_send_data(*str++);
}

void handle_buttons() {
    if (gpio_get(BUTTON_26)) {
        gpio_put(LED_28, 1);
        play_cool_buzzer_sound();  // Cool sound when BUTTON 26 is pressed
    }

    if (gpio_get(BUTTON_14)) {
        gpio_put(LED_28, 0);
        stop_buzzer();
    }

    static uint32_t button_15_press_time = 0;
    static bool led_27_on = false;

    if (gpio_get(BUTTON_15)) {
        if (button_15_press_time == 0) {
            button_15_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_15_press_time > 3000 && !led_27_on) {
            gpio_put(LED_27, 1);  // Turn on LED 27 after 3 seconds
            led_27_on = true;
        }
    } else {
        if (led_27_on) {
            gpio_put(LED_27, 0);  // Turn off LED 27 on release
            led_27_on = false;
        }
        button_15_press_time = 0;
    }
}

int main() {
    stdio_init_all();
    sleep_ms(2000);
    printf("[SYSTEM] Starting...\n");

    gpio_setup();
    lcd_init();

    while (1) {
        handle_buttons();
        sleep_ms(50);
    }
}
