#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// === LCD Pin Definitions === //
#define PIN_RS  17  
#define PIN_RW  19  
#define PIN_E   18  
#define PIN_RES 20  

// 8-bit Data Bus
const int data_pins[8] = {16, 3, 4, 5, 6, 7, 8, 9};

// Rotary Encoder Pins
#define ENCODER_A 10  
#define ENCODER_B 11  
#define ENCODER_BTN 12  

// Global Variables
volatile int menu_index = 0;
volatile bool in_settings_menu = false;
volatile uint32_t button_press_time = 0;
volatile bool button_pressed = false;
volatile int last_A = 0;
volatile int last_B = 0;
#define DEBOUNCE_DELAY_US 1000  // 1 ms debounce delay

void gpio_setup() {
    int control_pins[] = {PIN_RS, PIN_RW, PIN_E, PIN_RES};
    for (int i = 0; i < 4; i++) {
        gpio_init(control_pins[i]);
        gpio_set_dir(control_pins[i], GPIO_OUT);
    }

    for (int i = 0; i < 8; i++) {
        gpio_init(data_pins[i]);
        gpio_set_dir(data_pins[i], GPIO_OUT);
    }

    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_down(ENCODER_A);

    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_down(ENCODER_B);

    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_down(ENCODER_BTN);

    last_A = gpio_get(ENCODER_A);
    last_B = gpio_get(ENCODER_B);
}

// === LCD Helper Functions === //
void lcd_write_bus(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        gpio_put(data_pins[i], (data >> i) & 1);
    }
}

void lcd_pulse_enable() {
    gpio_put(PIN_E, 1);
    sleep_us(200);
    gpio_put(PIN_E, 0);
    sleep_us(200);
}

void lcd_send_command(uint8_t cmd) {
    gpio_put(PIN_RS, 0);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(cmd);
    lcd_pulse_enable();
    sleep_ms(2);
}

void lcd_send_data(uint8_t data) {
    gpio_put(PIN_RS, 1);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(data);
    lcd_pulse_enable();
    sleep_ms(1);
}

void lcd_init() {
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(200);

    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x06);
    sleep_ms(5);
    lcd_send_command(0x36);
    sleep_ms(10);
    lcd_send_command(0x09);
    sleep_ms(5);
    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x0C);
    sleep_ms(5);
    lcd_send_command(0x01);
    sleep_ms(10);

    printf("[LCD] Initialization Complete!\n");
}

void lcd_print(const char *str) {
    while (*str) {
        lcd_send_data(*str++);
    }
}

// === Function: Centered LCD Print === //
void lcd_print_centered(const char *str, uint8_t line) {
    uint8_t start_pos = (20 - strlen(str)) / 2;
    uint8_t ddram_address = 0x00;

    switch (line) {
        case 1: ddram_address = 0x00 + start_pos; break;
        case 2: ddram_address = 0x20 + start_pos; break;
        case 3: ddram_address = 0x40 + start_pos; break;
        case 4: ddram_address = 0x60 + start_pos; break;
    }

    lcd_send_command(0x80 | ddram_address);
    lcd_print(str);
}

// === Main Screen Display (Centered) === //
void display_main_screen() {
    lcd_send_command(0x01);  // Clear Display
    lcd_print_centered("MAIN SCREEN", 1);
    lcd_print_centered("0000 FEET", 2);
    lcd_print_centered("00 FT LBS", 3);
    printf("[LCD] Main Screen Displayed.\n");
}

// === Settings Menu Display (Left-Aligned with Right Arrow) === //
void display_settings_menu(int index) {
    const char *menu_items[] = {
        "1. Reel Up Speed",
        "2. Auto Stop Length",
        "3. Metric/Imperial",
        "4. Turn off Alarm",
        "5. Save Settings"
    };

    int start_index = index >= 4 ? index - 3 : 0;

    lcd_send_command(0x01);  // Clear Display
    for (int i = 0; i < 4; i++) {
        lcd_send_command(0x80 | (i * 0x20));  // Move to each line
        if (start_index + i < 5) {
            lcd_print(menu_items[start_index + i]);
            if (start_index + i == index) {
                lcd_send_command(0x80 | (i * 0x20 + 19));  // Move cursor to the last column
                lcd_print("<");
            }
        }
    }

    printf("[LCD] Settings Menu Item: %s\n", menu_items[index % 5]);
}

// === Button for Long Press Detection === //
void check_button_long_press() {
    if (gpio_get(ENCODER_BTN)) {
        if (!button_pressed) {
            button_pressed = true;
            button_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_press_time > 3000) {
            in_settings_menu = true;
            menu_index = 0;
            display_settings_menu(menu_index);
        }
    } else {
        button_pressed = false;
    }
}

// === Rotary Encoder Reading with Debounce === //
void read_encoder() {
    static uint32_t last_time = 0;
    uint32_t current_time = time_us_32();

    if (current_time - last_time < DEBOUNCE_DELAY_US) {
        return;  // Ignore if debounce time has not passed
    }

    int A = gpio_get(ENCODER_A);
    int B = gpio_get(ENCODER_B);

    if (A != last_A) {
        if (A == 1) {  // Rising edge on A
            if (B == 0) {
                menu_index++;
                if (menu_index > 4) menu_index = 4;
            } else {
                menu_index--;
                if (menu_index < 0) menu_index = 0;
            }
        }
        display_settings_menu(menu_index);
        printf("[ENCODER] Menu Index: %d\n", menu_index);
        last_time = current_time;
    }

    last_A = A;
    last_B = B;
}

// === Main Function === //
int main() {
    stdio_init_all();
    sleep_ms(2000);
    printf("[SYSTEM] Starting...\n");

    gpio_setup();
    lcd_init();
    display_main_screen();

    while (1) {
        if (in_settings_menu) {
            read_encoder();
        } else {
            check_button_long_press();
        }
        sleep_ms(50);
    }
}
