/*
 * ----------------------------------------------------
 * DDReels Mobile Device - Rotary Encoder Navigation (Early Implementation)
 * Project: Dynamic Drag Reels (D.D. Reels)
 * Author: Gabriel Joda
 * Platform: Raspberry Pi Pico W
 * Purpose: This code implements early rotary encoder navigation.
 *          It allows for switching between the main screen and settings menu.
 *
 *          Key Features:
 *            - Supports rotary encoder navigation through a settings menu.
 *            - Implements `display_settings_menu()` for handling menu UI.
 *            - Uses `check_button_long_press()` to detect long-press activation.
 *            - Displays the main screen by default, updating dynamically.
 *            - Debounce logic applied for stable encoder movement tracking.
 *
 *          Current Status:
 *            - ⚠️ Partially functional (Encoder scrolling requires additional tuning).
 *            - Button long-press detection is working.
 *            - LCD updates correctly but menu navigation needs improvements.
 *
 * Status: ⚠️ Partially functional, requires refinement.
 * ----------------------------------------------------
 */

#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// === LCD Pin Definitions === //
#define PIN_RS  17  // Register Select (RS)
#define PIN_RW  19  // Read/Write (Must be LOW for writing)
#define PIN_E   18  // Enable (E)
#define PIN_RES 20  // Reset (RES)

// 8-bit Data Bus for LCD
const int data_pins[8] = {16, 3, 4, 5, 6, 7, 8, 9};

// Rotary Encoder Pins
#define ENCODER_A 10  // Encoder Channel A
#define ENCODER_B 11  // Encoder Channel B
#define ENCODER_BTN 12  // Encoder push-button (active low)

// Global Variables
volatile int menu_index = 0;
volatile bool in_settings_menu = false;
volatile uint32_t button_press_time = 0;
volatile bool button_pressed = false;
volatile int last_A = 0;
volatile int last_B = 0;
#define DEBOUNCE_DELAY_US 1000  // 1 ms debounce delay

// === Function: Initialize GPIO === //
void gpio_setup() {
    int control_pins[] = {PIN_RS, PIN_RW, PIN_E, PIN_RES};
    for (int i = 0; i < 4; i++) {
        gpio_init(control_pins[i]);
        gpio_set_dir(control_pins[i], GPIO_OUT);
    }

    for (int i = 0; i < 8; i++) {
        gpio_init(data_pins[i]);
        gpio_set_dir(data_pins[i], GPIO_OUT);
    }

    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_down(ENCODER_A);

    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_down(ENCODER_B);

    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_down(ENCODER_BTN);

    last_A = gpio_get(ENCODER_A);
    last_B = gpio_get(ENCODER_B);
}

// === LCD Helper Functions === //
void lcd_write_bus(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        gpio_put(data_pins[i], (data >> i) & 1);
    }
}

void lcd_pulse_enable() {
    gpio_put(PIN_E, 1);
    sleep_us(200);
    gpio_put(PIN_E, 0);
    sleep_us(200);
}

void lcd_send_command(uint8_t cmd) {
    gpio_put(PIN_RS, 0);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(cmd);
    lcd_pulse_enable();
    sleep_ms(2);
}

void lcd_send_data(uint8_t data) {
    gpio_put(PIN_RS, 1);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(data);
    lcd_pulse_enable();
    sleep_ms(1);
}

void lcd_init() {
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(200);

    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x06);
    sleep_ms(5);
    lcd_send_command(0x36);
    sleep_ms(10);
    lcd_send_command(0x09);
    sleep_ms(5);
    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x0C);
    sleep_ms(5);
    lcd_send_command(0x01);
    sleep_ms(10);

    printf("[LCD] Initialization Complete!\n");
}

void display_main_screen() {
    lcd_send_command(0x01);  // Clear Display
    lcd_send_data("MAIN SCREEN");
    printf("[LCD] Main Screen Displayed.\n");
}

// === Function: Display Settings Menu === //
void display_settings_menu(int index) {
    const char *menu_items[] = {
        "1. Reel Up Speed",
        "2. Auto Stop Length",
        "3. Metric/Imperial",
        "4. Turn off Alarm",
        "5. Save Settings"
    };
    
    lcd_send_command(0x01);  // Clear Display
    lcd_send_data(menu_items[index % 5]);  // Print selected menu item
}

// === Function: Read Encoder for Navigation === //
void read_encoder() {
    static uint32_t last_time = 0;
    uint32_t current_time = time_us_32();
    if (current_time - last_time < DEBOUNCE_DELAY_US) {
        return;
    }

    int A = gpio_get(ENCODER_A);
    int B = gpio_get(ENCODER_B);
    if (A != last_A) {
        if (A == 1) {
            menu_index++;
        } else {
            menu_index--;
        }
        display_settings_menu(menu_index);
        last_time = current_time;
    }
    last_A = A;
}

// === Function: Check Button Long Press === //
void check_button_long_press() {
    if (gpio_get(ENCODER_BTN)) {
        if (!button_pressed) {
            button_pressed = true;
            button_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_press_time > 3000) {
            in_settings_menu = true;
            menu_index = 0;
            display_settings_menu(menu_index);
        }
    } else {
        button_pressed = false;
    }
}

// === Main Function === //
int main() {
    stdio_init_all();
    sleep_ms(2000);
    gpio_setup();
    lcd_init();
    display_main_screen();
    
    while (1) {
        if (in_settings_menu) {
            read_encoder();
        } else {
            check_button_long_press();
        }
        sleep_ms(50);
    }
}
