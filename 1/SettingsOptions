#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/gpio.h"

// === LCD Pin Definitions === //
#define PIN_RS   17  
#define PIN_RW   19  
#define PIN_E    18  
#define PIN_RES  20  

// 8-bit Data Bus
const int data_pins[8] = {16, 3, 4, 5, 6, 7, 8, 9};

// Rotary Encoder Pins
#define ENCODER_A    10  
#define ENCODER_B    11  
#define ENCODER_BTN  12  

// Button and LED Pins
#define BUTTON_26    26
#define BUTTON_14    14
#define BUTTON_15    15
#define LED_28       28
#define LED_13       13
#define LED_27       27

// Global variables for settings menu
volatile int menu_index = 0;  // current selection (0-4)
volatile bool in_settings_menu = false;
volatile uint32_t button_press_time = 0;
volatile bool button_pressed = false;

// Flags used in the encoder ISR (for debouncing simple edges)
volatile bool cw_fall = false;
volatile bool ccw_fall = false;

// For LCD refresh in main loop
int last_menu_index = -1;

// New flag to ignore the next encoder button press when entering settings.
volatile bool ignore_next_press = false;

// Flag for when a subpage is active.
volatile bool in_submenu = false;

// --- Parameters to adjust ---
int reel_speed = 50;       // 0 to 100 (%), step 10
int stop_length = 10;      // in ft, step 1 (range 0-100)
bool metric_mode = false;  // false = Imperial, true = Metric
bool alarm_enabled = true; // Alarm is enabled by default

// --- LCD Helper Functions ---
void lcd_write_bus(uint8_t data) {
    for (int i = 0; i < 8; i++) {
        gpio_put(data_pins[i], (data >> i) & 1);
    }
}

void lcd_pulse_enable() {
    gpio_put(PIN_E, 1);
    sleep_us(200);
    gpio_put(PIN_E, 0);
    sleep_us(200);
}

void lcd_send_command(uint8_t cmd) {
    gpio_put(PIN_RS, 0);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(cmd);
    lcd_pulse_enable();
    sleep_ms(2);
}

void lcd_send_data(uint8_t data) {
    gpio_put(PIN_RS, 1);
    gpio_put(PIN_RW, 0);
    lcd_write_bus(data);
    lcd_pulse_enable();
    sleep_ms(1);
}

void lcd_init() {
    gpio_put(PIN_RES, 0);
    sleep_ms(50);
    gpio_put(PIN_RES, 1);
    sleep_ms(200);

    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x06);
    sleep_ms(5);
    lcd_send_command(0x36);
    sleep_ms(10);
    lcd_send_command(0x09);
    sleep_ms(5);
    lcd_send_command(0x30);
    sleep_ms(10);
    lcd_send_command(0x0C);
    sleep_ms(5);
    lcd_send_command(0x01);
    sleep_ms(10);

    printf("[LCD] Initialization Complete!\n");
}

void lcd_print(const char *str) {
    while (*str) {
        lcd_send_data(*str++);
    }
}

void lcd_print_centered(const char *str, uint8_t line) {
    uint8_t start_pos = (20 - strlen(str)) / 2;
    uint8_t ddram_address = 0x00;
    switch (line) {
        case 1: ddram_address = 0x00 + start_pos; break;
        case 2: ddram_address = 0x20 + start_pos; break;
        case 3: ddram_address = 0x40 + start_pos; break;
        case 4: ddram_address = 0x60 + start_pos; break;
    }
    lcd_send_command(0x80 | ddram_address);
    lcd_print(str);
}

void display_main_screen() {
    lcd_send_command(0x01);  // Clear display
    lcd_print_centered("MAIN SCREEN", 1);
    lcd_print_centered("0000 FEET", 2);
    lcd_print_centered("00 FT LBS", 3);
    printf("[LCD] Main Screen Displayed.\n");
}

void display_settings_menu(int index) {
    const char *menu_items[] = {
        "1.Reel Up Speed",
        "2.Auto Stop Length",
        "3.Metric/Imperial",
        "4.Turn off Alarm",
        "5.Save Settings"
    };
    int start_index = index >= 4 ? index - 3 : 0;
    lcd_send_command(0x01);  // Clear display
    for (int i = 0; i < 4; i++) {
        lcd_send_command(0x80 | (i * 0x20));
        if (start_index + i < 5) {
            lcd_print(menu_items[start_index + i]);
            if (start_index + i == index) {
                lcd_send_command(0x80 | ((i * 0x20) + 19));
                lcd_print("<");
            }
        }
    }
    printf("[LCD] Settings Menu Item: %s\n", menu_items[index % 5]);
}

// --- Subpage Display Update --- //
void update_subpage_display() {
    lcd_send_command(0x01); // Clear display
    switch(menu_index) {
        case 0: {
            lcd_print_centered("Speed percentage", 1);
            char buf[21];
            sprintf(buf, "%d%%", reel_speed);
            lcd_print_centered(buf, 2);
            break;
        }
        case 1: {
            lcd_print_centered("Stop Length", 1);
            char buf[21];
            sprintf(buf, "%d FT", stop_length);
            lcd_print_centered(buf, 2);
            break;
        }
        case 2: {
            lcd_print_centered("Metric/Imperial", 1);
            lcd_print_centered(metric_mode ? "Metric" : "Imperial", 2);
            break;
        }
        case 3: {
            lcd_print_centered("Turn off Alarm", 1);
            lcd_print_centered(alarm_enabled ? "Alarm ON" : "Alarm OFF", 2);
            break;
        }
        case 4: {
            lcd_print_centered("Save Settings", 1);
            lcd_print_centered("Press to save", 2);
            break;
        }
        default:
            lcd_print_centered("Undefined", 1);
            break;
    }
}

// --- Open Subpage --- //
// When a short press is detected in the settings menu, this opens the appropriate subpage.
void open_subpage(int selection) {
    in_submenu = true;
    update_subpage_display();
    printf("[SUBPAGE] Opened subpage for selection %d\n", selection);
}

// --- Encoder Button Handling in Settings/Subpage --- //
// When in settings menu (and not yet in subpage) a short press opens the subpage.
// We ignore the very next press after entering settings (ignore_next_press flag).
void check_settings_selection() {
    static bool was_pressed = false;
    static uint32_t press_time = 0;
    bool current = !gpio_get(ENCODER_BTN); // active low

    if (ignore_next_press) {
        if (gpio_get(ENCODER_BTN)) { // wait for release
            ignore_next_press = false;
        }
        return;
    }
    
    if (current && !was_pressed) {
        press_time = to_ms_since_boot(get_absolute_time());
        was_pressed = true;
    } else if (!current && was_pressed) {
        uint32_t duration = to_ms_since_boot(get_absolute_time()) - press_time;
        // For settings menu, a short press (<3000ms) opens the subpage.
        if (duration < 3000) {
            open_subpage(menu_index);
        }
        was_pressed = false;
    }
}

// When in a subpage, handle encoder-button presses.
// For numeric subpages (0 and 1) a long press (>=3000ms) exits the subpage.
// For toggle subpages (2, 3, 4), a short press (<3000ms) toggles the setting, and a long press exits.
void check_submenu_exit() {
    static bool was_pressed = false;
    static uint32_t press_time = 0;
    bool current = !gpio_get(ENCODER_BTN);
    
    if (current && !was_pressed) {
        press_time = to_ms_since_boot(get_absolute_time());
        was_pressed = true;
    } else if (!current && was_pressed) {
        uint32_t duration = to_ms_since_boot(get_absolute_time()) - press_time;
        if (menu_index == 0 || menu_index == 1) {
            // Numeric subpages: only exit on long press.
            if (duration >= 3000) {
                in_submenu = false;
                display_settings_menu(menu_index);
                last_menu_index = menu_index;
                printf("[SUBPAGE] Exiting numeric subpage.\n");
            }
        } else {
            // Toggle subpages (2,3,4)
            if (duration < 3000) {
                if (menu_index == 2) {
                    metric_mode = !metric_mode;
                } else if (menu_index == 3) {
                    alarm_enabled = !alarm_enabled;
                    if (!alarm_enabled) {
                        // Disable outputs by setting LED pins to input.
                        gpio_set_dir(LED_28, GPIO_IN);
                        gpio_set_dir(LED_13, GPIO_IN);
                    } else {
                        gpio_set_dir(LED_28, GPIO_OUT);
                        gpio_set_dir(LED_13, GPIO_OUT);
                    }
                } else if (menu_index == 4) {
                    // Simulate saving settings.
                    printf("[SAVE] Settings saved: Speed=%d%%, Length=%dFT, Mode=%s, Alarm=%s\n",
                           reel_speed, stop_length,
                           metric_mode ? "Metric" : "Imperial",
                           alarm_enabled ? "ON" : "OFF");
                }
                update_subpage_display();
            } else {  // long press: exit subpage
                in_submenu = false;
                display_settings_menu(menu_index);
                last_menu_index = menu_index;
                printf("[SUBPAGE] Exiting toggle subpage.\n");
            }
        }
        was_pressed = false;
    }
}

// --- Rotary Encoder Interrupt Callback --- //
void encoder_callback(uint gpio, uint32_t events) {
    // Read encoder pins (bits 10 and 11)
    uint32_t gpio_state = (gpio_get_all() >> 10) & 0b11;
    if (!in_submenu) {
        // In settings menu mode, use your existing simple method.
        if (gpio == ENCODER_A) {
            if (!cw_fall && (gpio_state == 0b10)) {
                cw_fall = true;
            }
            if (ccw_fall && (gpio_state == 0b00)) {  // CCW detected
                ccw_fall = false;
                cw_fall = false;
                menu_index--;
                if (menu_index < 0) menu_index = 0;
                printf("[ENCODER] CCW - Menu index: %d\n", menu_index);
            }
        } else if (gpio == ENCODER_B) {
            if (!ccw_fall && (gpio_state == 0b01)) {
                ccw_fall = true;
            }
            if (cw_fall && (gpio_state == 0b00)) {  // CW detected
                cw_fall = false;
                ccw_fall = false;
                menu_index++;
                if (menu_index > 4) menu_index = 4;
                printf("[ENCODER] CW - Menu index: %d\n", menu_index);
            }
        }
    } else {
        // In a subpage, update parameters for numeric subpages (0 and 1).
        if (gpio == ENCODER_A) {
            if (!cw_fall && (gpio_state == 0b10)) {
                cw_fall = true;
            }
            if (ccw_fall && (gpio_state == 0b00)) {
                ccw_fall = false;
                cw_fall = false;
                if (menu_index == 0) { // Reel Up Speed
                    reel_speed -= 10;
                    if (reel_speed < 0) reel_speed = 0;
                } else if (menu_index == 1) { // Stop Length
                    stop_length -= 1;
                    if (stop_length < 0) stop_length = 0;
                }
                update_subpage_display();
                printf("[SUBPAGE] Updated (CCW) - ");
                if(menu_index==0) printf("Speed: %d%%\n", reel_speed);
                else if(menu_index==1) printf("Length: %d FT\n", stop_length);
            }
        } else if (gpio == ENCODER_B) {
            if (!ccw_fall && (gpio_state == 0b01)) {
                ccw_fall = true;
            }
            if (cw_fall && (gpio_state == 0b00)) {
                cw_fall = false;
                ccw_fall = false;
                if (menu_index == 0) { // Reel Up Speed
                    reel_speed += 10;
                    if (reel_speed > 100) reel_speed = 100;
                } else if (menu_index == 1) { // Stop Length
                    stop_length += 1;
                    if (stop_length > 100) stop_length = 100;
                }
                update_subpage_display();
                printf("[SUBPAGE] Updated (CW) - ");
                if(menu_index==0) printf("Speed: %d%%\n", reel_speed);
                else if(menu_index==1) printf("Length: %d FT\n", stop_length);
            }
        }
    }
}

// --- Other Button Handlers --- //
// When not in settings mode, a long press enters settings.
void check_button_long_press() {
    if (!in_settings_menu && !gpio_get(ENCODER_BTN)) { // active low
        if (!button_pressed) {
            button_pressed = true;
            button_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_press_time > 3000) {
            in_settings_menu = true;
            menu_index = 0;
            display_settings_menu(menu_index);
            last_menu_index = menu_index;
            ignore_next_press = true; // ignore the very next short press
            printf("[SETTINGS] Entering settings menu via long press.\n");
        }
    } else if (gpio_get(ENCODER_BTN)) {
        button_pressed = false;
    }
}

void handle_buttons() {
    if (gpio_get(BUTTON_26)) {
        gpio_put(LED_28, 1);
        gpio_put(LED_13, 1);
    }
    if (gpio_get(BUTTON_14)) {
        gpio_put(LED_28, 0);
        gpio_put(LED_13, 0);
    }
    
    static uint32_t button_15_press_time = 0;
    static bool led_27_on = false;
    static bool button_15_released = true;
    if (gpio_get(BUTTON_15)) {
        if (button_15_press_time == 0 && button_15_released) {
            button_15_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_15_press_time > 3000 && !led_27_on) {
            gpio_put(LED_27, 1);
            led_27_on = true;
            button_15_released = false;
        }
    } else {
        if (button_15_press_time > 0) {
            if (!led_27_on) {
                gpio_put(LED_27, 0);
            } else {
                led_27_on = false;
            }
            button_15_press_time = 0;
            button_15_released = true;
        }
    }
}

// --- GPIO Setup ---
void gpio_setup() {
    // LCD Control Pins
    int control_pins[] = {PIN_RS, PIN_RW, PIN_E, PIN_RES};
    for (int i = 0; i < 4; i++) {
        gpio_init(control_pins[i]);
        gpio_set_dir(control_pins[i], GPIO_OUT);
    }
    // LCD Data Bus
    for (int i = 0; i < 8; i++) {
        gpio_init(data_pins[i]);
        gpio_set_dir(data_pins[i], GPIO_OUT);
    }
    // Rotary Encoder Pins
    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_up(ENCODER_A);
    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_up(ENCODER_B);
    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_up(ENCODER_BTN);
    // Set up interrupts for encoder (both edges for responsiveness)
    gpio_set_irq_enabled_with_callback(ENCODER_A, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &encoder_callback);
    gpio_set_irq_enabled(ENCODER_B, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true);
    // Other Buttons and LEDs
    gpio_init(BUTTON_26);
    gpio_set_dir(BUTTON_26, GPIO_IN);
    gpio_pull_down(BUTTON_26);
    gpio_init(BUTTON_14);
    gpio_set_dir(BUTTON_14, GPIO_IN);
    gpio_pull_down(BUTTON_14);
    gpio_init(BUTTON_15);
    gpio_set_dir(BUTTON_15, GPIO_IN);
    gpio_pull_down(BUTTON_15);
    gpio_init(LED_28);
    gpio_set_dir(LED_28, GPIO_OUT);
    gpio_put(LED_28, 0);
    gpio_init(LED_13);
    gpio_set_dir(LED_13, GPIO_OUT);
    gpio_put(LED_13, 0);
    gpio_init(LED_27);
    gpio_set_dir(LED_27, GPIO_OUT);
    gpio_put(LED_27, 0);
}

int main() {
    stdio_init_all();
    sleep_ms(2000);
    printf("[SYSTEM] Starting...\n");
    gpio_setup();
    lcd_init();
    display_main_screen();

    while (1) {
        if (!in_settings_menu) {
            check_button_long_press();
        }
        if (in_settings_menu) {
            if (in_submenu) {
                check_submenu_exit();
            } else {
                check_settings_selection();
                if (menu_index != last_menu_index) {
                    display_settings_menu(menu_index);
                    last_menu_index = menu_index;
                }
            }
        }
        handle_buttons();
        sleep_ms(50);
    }
}
