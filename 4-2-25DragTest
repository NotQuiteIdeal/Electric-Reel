#include <stdio.h>
#include <string.h>
#include "hardware/gpio.h"
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/timer.h"
#include "hardware/clocks.h"
#include "pico/binary_info.h"
#include "math.h"
#include "time.h"
#include "pico/multicore.h"

// LCD control constants for sending commands and data to the LCD screen
const int LCD_CLEARDISPLAY = 0x01;
const int LCD_RETURNHOME = 0x02;
const int LCD_ENTRYMODESET = 0x04;
const int LCD_DISPLAYCONTROL = 0x08;
const int LCD_CURSORSHIFT = 0x10;
const int LCD_FUNCTIONSET = 0x20;
const int LCD_SETCGRAMADDR = 0x40;
const int LCD_SETDDRAMADDR = 0x80;

// Multicore variables for handling encoder counts and calculations
volatile int length = 0; 
volatile int drag = 0;
int count = 0;
int rotations = 0;
int count_drag = 0;
int oldVal = 0;
int newVal = 0;

// LCD flags for controlling display attributes like cursor, blink, etc.
const int LCD_ENTRYSHIFTINCREMENT = 0x01;
const int LCD_ENTRYLEFT = 0x02;
const int LCD_BLINKON = 0x01;
const int LCD_CURSORON = 0x02;
const int LCD_DISPLAYON = 0x04;
const int LCD_MOVERIGHT = 0x04;
const int LCD_DISPLAYMOVE = 0x08;
const int LCD_5x10DOTS = 0x04;
const int LCD_2LINE = 0x08;
const int LCD_8BITMODE = 0x10;
const int LCD_BACKLIGHT = 0x08;
const int LCD_ENABLE_BIT = 0x04;

// Default I2C LCD address
static int addr = 0x27;

// Define modes for sending data or commands to the LCD
#define LCD_CHARACTER  1
#define LCD_COMMAND    0

#define MAX_LINES      2
#define MAX_CHARS      16

// I2C write function to send a byte to the LCD
void i2c_write_byte(uint8_t val) {
#ifdef i2c_default
    i2c_write_blocking(i2c_default, addr, &val, 1, false); // Send 1 byte over I2C
#endif
}

// Toggle the enable pin for the LCD communication (used for the I2C interface)
void lcd_toggle_enable(uint8_t val) {
    sleep_us(600); // Wait for some time
    i2c_write_byte(val | LCD_ENABLE_BIT); // Set enable pin high
    sleep_us(600); // Wait for some time
    i2c_write_byte(val & ~LCD_ENABLE_BIT); // Set enable pin low
    sleep_us(600); // Wait for some time
}

// Send a byte (command or data) to the LCD
void lcd_send_byte(uint8_t val, int mode) {
    uint8_t high = mode | (val & 0xF0) | LCD_BACKLIGHT; // Prepare high nibble
    uint8_t low = mode | ((val << 4) & 0xF0) | LCD_BACKLIGHT; // Prepare low nibble

    i2c_write_byte(high); // Send high nibble
    lcd_toggle_enable(high); // Toggle enable pin
    i2c_write_byte(low); // Send low nibble
    lcd_toggle_enable(low); // Toggle enable pin
}

// Clear the LCD display by sending the clear display command
void lcd_clear(void) {
    lcd_send_byte(LCD_CLEARDISPLAY, LCD_COMMAND);
}

// Set the cursor position on the LCD (either line 0 or line 1)
void lcd_set_cursor(int line, int position) {
    int val = (line == 0) ? 0x80 + position : 0xC0 + position; // Set position on either line 0 or 1
    lcd_send_byte(val, LCD_COMMAND);
}

// Send a single character to the LCD
static inline void lcd_char(char val) {
    lcd_send_byte(val, LCD_CHARACTER); // Send the character byte
}

// Display a string on the LCD
void lcd_string(const char *s) {
    while (*s) { // Iterate over the string until null-terminator is reached
        lcd_char(*s++); // Send each character to the LCD
    }
}

// Initialize the LCD display with standard commands to set it up
void lcd_init() {
    lcd_send_byte(0x03, LCD_COMMAND); // Initialize sequence
    lcd_send_byte(0x03, LCD_COMMAND); // Initialize sequence
    lcd_send_byte(0x03, LCD_COMMAND); // Initialize sequence
    lcd_send_byte(0x02, LCD_COMMAND); // Set 4-bit mode

    lcd_send_byte(LCD_ENTRYMODESET | LCD_ENTRYLEFT, LCD_COMMAND); // Set entry mode
    lcd_send_byte(LCD_FUNCTIONSET | LCD_2LINE, LCD_COMMAND); // Set function (2 lines, 5x8)
    lcd_send_byte(LCD_DISPLAYCONTROL | LCD_DISPLAYON, LCD_COMMAND); // Turn on display
    lcd_clear(); // Clear display
}

// Initialize I2C and LCD
void i2c_lcd_init() {
#if !defined(i2c_default) || !defined(PICO_DEFAULT_I2C_SDA_PIN) || !defined(PICO_DEFAULT_I2C_SCL_PIN)
    #warning i2c/lcd_1602_i2c example requires a board with I2C pins
#else
    i2c_init(i2c_default, 100 * 1000); // Initialize I2C bus with 100kHz clock speed
    gpio_set_function(PICO_DEFAULT_I2C_SDA_PIN, GPIO_FUNC_I2C); // Set SDA pin for I2C
    gpio_set_function(PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C); // Set SCL pin for I2C
    gpio_pull_up(PICO_DEFAULT_I2C_SDA_PIN); // Enable pull-up on SDA
    gpio_pull_up(PICO_DEFAULT_I2C_SCL_PIN); // Enable pull-up on SCL
    bi_decl(bi_2pins_with_func(PICO_DEFAULT_I2C_SDA_PIN, PICO_DEFAULT_I2C_SCL_PIN, GPIO_FUNC_I2C)); // Declare I2C pins
    lcd_init(); // Initialize LCD display
#endif
}

// Function to calculate the length based on encoder rotations
int calculate_length(double Dmax, double Dmin, double rotations)
{
    double PI = 3.14;
    double part1 = (Dmax * PI) / 12.0; // Calculate part of the length formula
    double part2 = (Dmax - Dmin) / (12 * 2426.2 * pow((rotations / 0.9231), (5000.0 / 5119.0)) * pow(1, -0.985)); // Calculate other part
    int tempLength = (part1 - part2) * rotations; // Calculate total length
    return tempLength; // Return calculated length
}

// Update the drag value based on drag count from the encoder
int update_drag(double count_drag) {
    if (count_drag >= 0 && count_drag <= 8) {
        drag = 00;
    } else if (count_drag >= 9 && count_drag <= 23) {
        drag = 05;
    } else if (count_drag >= 24 && count_drag <= 33) {
        drag = 10;
    } else if (count_drag >= 34 && count_drag <= 46) {
        drag = 15;
    } else if (count_drag >= 47 && count_drag <= 58) {
        drag = 20;
    } else if (count_drag >= 59 && count_drag <= 70) {
        drag = 25;
    } else if (count_drag >= 71 && count_drag <= 84) {
        drag = 30;
    } else if (count_drag >= 85 && count_drag <= 99) {
        drag = 35;
    } else if (count_drag >= 100 && count_drag <= 110) {
        drag = 40;
    } else if (count_drag >= 111 && count_drag <= 124) {
        drag = 45;
    } else if (count_drag >= 125 && count_drag <= 139) {
        drag = 50;
    } else if (count_drag >= 140 && count_drag <= 150) {
        drag = 55;
    } else if (count_drag >= 151 && count_drag <= 165) {
        drag = 60;
    } else if (count_drag >= 166 && count_drag <= 178) {
        drag = 65;
    } else if (count_drag >= 179 && count_drag <= 192) {
        drag = 70;
    }
    return drag; // Return the calculated drag
}

// Display a message to set drag to zero
void display_set_drag_to_zero() {
    lcd_set_cursor(0, 0); // Set cursor to the first line
    lcd_string("Set Drag To Zero"); // Display message on the LCD
}

// Display length and drag values on the LCD
void display(int lineLength, int drag) {
    char LengthStr[16];
    char dragStr[16];
    char *message[] = {
        "Length:", "",
        "Drag:  ", ""
    };
    snprintf(LengthStr, sizeof(LengthStr), "%d", lineLength); // Convert length to string
    snprintf(dragStr, sizeof(dragStr), "%d", drag); // Convert drag to string
    message[1] = LengthStr; // Store length string in message
    message[3] = dragStr; // Store drag string in message

    lcd_set_cursor(0, 0);  // Set cursor to the first line
    lcd_string(message[0]);  // Display "Length:" text
    lcd_string(message[1]);  // Display the actual length value

    lcd_set_cursor(1, 0);  // Set cursor to the second line
    lcd_string(message[2]);  // Display "Drag:" text
    lcd_string(message[3]);  // Display the actual drag value
}

// Function for Core1 to manage the LCD display and updates
void display_Core1() {
    stdio_init_all(); // Initialize standard input/output

    int receivedLength = 0;
    int receivedDrag = 0;
    int button = gpio_get(15); // Read button state
    lcd_clear(); // Clear the LCD screen

    while (button == 0) { 
        button = gpio_get(15); // Wait for button press to continue
        display_set_drag_to_zero(); // Show the message to set drag to zero
    }

    lcd_clear(); // Clear the display after button press
    while(true) {
        // Update LCD only if values have changed (prevents unnecessary updates)
        if (length != receivedLength){
            if (receivedLength == 10 || receivedLength == 100 || receivedLength == 1000){
                lcd_clear();
            }
        }
        if (drag != receivedDrag){
            if (drag == 5 || drag == 100){
                lcd_clear();
            }
        }

        receivedLength = length;
        receivedDrag = drag;
        display(receivedLength, receivedDrag); // Update the display with current length and drag
        sleep_ms(200); // Delay to prevent too frequent updates
    }
}

int main() {
    stdio_init_all(); // Initialize standard I/O

    // Initialize GPIO pins for input
    gpio_init(15); 
    gpio_set_dir(15, GPIO_IN); 
    gpio_init(8); 
    gpio_set_dir(8, GPIO_IN); 
    gpio_init(9); 
    gpio_set_dir(9, GPIO_IN); 
    gpio_init(10); 
    gpio_set_dir(10, GPIO_IN); 
    gpio_init(11); 
    gpio_set_dir(11, GPIO_IN);

    i2c_lcd_init(); // Initialize the LCD and I2C

    multicore_launch_core1(display_Core1); // Launch Core1 to handle LCD display updates

    double Dmax = 3.685;
    double Dmin = 2.00;
    int rotations = 0;
    int count = 0;
    int count_drag = 0;
    int oldVal = 0;
    int newVal = 0;
    int oldValdrag = 0;
    int newValdrag = 0;
    int buttonPressed = 0;
    int button = 0;

    while (true) {
        if (gpio_get(15) == 1){ // If button is pressed, reset drag count
            count_drag = 0;
            drag = 0;
        }

        int chanA = gpio_get(10); // Read encoder channels for rotation count
        int chanB = gpio_get(11);
        int chanDragA = gpio_get(8); // Read encoder channels for drag count
        int chanDragB = gpio_get(9);

        // Update rotation count based on encoder signals
        if (chanA == 1) {
            if (chanB == 1){
                newVal = 11;
            } else {
                newVal = 10;
            }
        } else {
            if (chanB == 1){
                newVal = 01;
            } else {
                newVal = 00;
            }
        }

        // Update drag count based on encoder signals
        if (chanDragA == 1) {
            if (chanDragB == 1) {
                newValdrag = 11;
            } else {
                newValdrag = 10;
            }
        } else {
            if (chanDragB == 1) {
                newValdrag = 01;
            } else {
                newValdrag = 00;
            }
        }

        // Update rotation count and calculate line length
        if (newVal != oldVal) { 
             if (oldVal == 11) {
                 if (newVal == 10) {
                     gpio_put(22, 1);
                     count--;
                 } else {
                     gpio_put(22, 0);
                     count++;
                 }
             } else if (oldVal == 10) {
                 if (newVal == 00) {
                     gpio_put(22, 1);
                     count--;
                 } else {
                     gpio_put(22, 0);
                     count++;
                 }
             } else if (oldVal == 00) {
                 if (newVal == 01) {
                     gpio_put(22, 1);
                     count--;
                 } else {
                     gpio_put(22, 0);
                     count++;
                 }
             } else if (oldVal == 01) {
                 if (newVal == 11) {
                     gpio_put(22, 1);
                     count--;
                 } else {
                     gpio_put(22, 0);
                     count++;
                 }
             } 
             if (count==208){
                 rotations++;
                 count = 0; 
             }
             if (count == -208){  
                 --rotations;
                 count = 0;        
             }
             if (rotations >=1) {
                 length = calculate_length(Dmax, Dmin, rotations);
             }
         }
         oldVal = newVal;

        // Update drag count based on encoder
         if (newValdrag != oldValdrag) {
            if (oldValdrag == 11) {
                if (newValdrag == 10) {
                    gpio_put(22, 1);
                    count_drag--;
                } else {
                    gpio_put(22, 0);
                    count_drag++;
                }
            } else if (oldValdrag == 10) {
                if (newValdrag == 00) {
                    gpio_put(22, 1);
                    count_drag--;
                } else {
                    gpio_put(22, 0);
                    count_drag++;
                }
            } else if (oldValdrag == 00) {
                if (newValdrag == 01) {
                    gpio_put(22, 1);
                    count_drag--;
                } else {
                    gpio_put(22, 0);
                    count_drag++;
                }
            } else if (oldValdrag == 01) {
                if (newValdrag == 11) {
                    gpio_put(22, 1);
                    count_drag--;
                } else {
                    gpio_put(22, 0);
                    count_drag++;
                }
                
                //printf("count: %d\n", count_drag);
            }
            if (count_drag >=1) {
                drag =  update_drag(count_drag);
            }
            printf("drag: %d\n", drag); // Print drag value for debugging
        }
        //update_drag();
        oldValdrag = newValdrag;
         //Clears queue and updates length value for core1    
     } 
}
