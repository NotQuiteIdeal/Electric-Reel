#include <stdio.h>
#include <string.h>
#include "pico/stdlib.h"
#include "hardware/i2c.h"
#include "hardware/timer.h"
#include "hardware/gpio.h"
#include "pico/multicore.h"
#define I2C_PORT i2c0
#define SDA_PIN 4
#define SCL_PIN 5
#define CFA634_I2C_ADDR 0x42  // I2C address (7-bit format)
#define ENCODER_A 1
#define ENCODER_B 0
#define ENCODER_BTN 2
#define RBTN 6
#define LBTN 7
#define Buzz 11
volatile bool menuActive = false;
volatile bool button_pressed = false;
volatile uint32_t button_press_time = 0;
volatile bool in_settings_menu = false;
volatile int menu_index = 0;
volatile bool cw_fall = false;
volatile bool ccw_fall = false;
int last_menu_index = -1;
volatile bool ignore_next_press = false;
volatile bool in_submenu = false;
volatile int selected_digit = 0;
volatile int value_to_modify = 0;
volatile bool isImperial = false; //false = metric, true = imperial
int AutoStopLen[2] = {0,0};
int MaxSpeed[2] = {0,0};
int MinSpeed[2] = {0,0};
int SpoolDiameter[2] = {0.0};
volatile int selected_menu = 0;
volatile bool right_pressed = false;
volatile bool left_pressed = false;
volatile bool buzz_en = false;
// Function to send a command to the LCD
void cfa634_send_command(uint8_t cmd) {
    uint8_t buffer[2] = {0xFE, cmd};  // Command format
    int result = i2c_write_blocking(I2C_PORT, CFA634_I2C_ADDR, buffer, 2, false);
    sleep_ms(100);
}
void setcursor(uint8_t col, uint8_t row){
    uint8_t buffer[3] = {0x11, col, row};
    int result = i2c_write_blocking(I2C_PORT, CFA634_I2C_ADDR, buffer, 3, false);
    sleep_ms(50);
}
void cfa634_print(const char *text, uint8_t col, uint8_t row) {
    uint8_t display_width = 24; // CFA-634 is a 20-column display
    size_t text_length = strlen(text);
    if (text_length > display_width) {
        text_length = display_width; // Trim text if it's too long
    }
    size_t leading_spaces = (display_width - text_length) / 2; // Center alignment
    char padded_text[display_width + 1]; // +1 for null terminator
    snprintf(padded_text, sizeof(padded_text), "%*s%s", (int)leading_spaces, " ", text);
    setcursor(col, row);
    for (size_t i = 0; i < strlen(padded_text); i++) { // send padded number to display
        i2c_write_blocking(I2C_PORT, CFA634_I2C_ADDR, (uint8_t *)&padded_text[i], 1, false);
        sleep_ms(2); // Small delay for LCD to process
    }
}
void i2c_setup() {
    i2c_init(I2C_PORT, 100 * 1000);  // Set I2C speed to 100 kHz
    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SDA_PIN);
    gpio_pull_up(SCL_PIN);
}
void cfa634_clear_screen() {
    uint8_t clear_cmd = 0x0C;  // Form Feed (Control+L) in ASCII
    int result = i2c_write_blocking(I2C_PORT, CFA634_I2C_ADDR, &clear_cmd, 1, false);
    sleep_ms(3);  // Give LCD time to process
}
void selectedmenudisplay(int pos){
    switch (pos) {
        case 0:
            cfa634_print("       SAVING       ",0,0);
            cfa634_print("                    ",0,1);
            cfa634_print("  RETURNING TO MAIN ",0,2);
            cfa634_print("                    ",0,3);
            break;
        case 1:
            cfa634_print("                    ",0,0);
            cfa634_print("    RESETTING LINE  ",0,1);
            cfa634_print(" PRESS DIAL > RETURN",0,2);
            cfa634_print("                    ",0,3);
            break;
        case 2:
            char display_value[21];
            char cursor_position[21] = "           ^         "; // Default cursor below second digit
            sprintf(display_value, "         %d%d         ", AutoStopLen[0], AutoStopLen[1]);
            // Move the cursor to the correct digit position
            cursor_position[10 + selected_digit] = '^';
            cfa634_print("   ENTER AUTO STOP  ", 0, 0);
            cfa634_print("  LENGTH VALUE 0-9  ", 0, 1);
            cfa634_print(display_value, 0, 2);
            cfa634_print(cursor_position, 0, 3);
            break;
        case 3:
            cfa634_print(isImperial ? "    CURRENT: IMPERIAL" : "    CURRENT: METRIC", 0, 0);
            cfa634_print("    LEFT > METRIC   ",0,1);
            cfa634_print("   RIGHT > IMPERIAL ",0,2);
            cfa634_print(" PRESS DIAL > RETURN",0,3);
            break;
        case 4:
            char display_value1[21];
            char cursor_position1[21] = "           ^         "; // Default cursor below second digit
            sprintf(display_value, "         %d%d         ", MaxSpeed[0], MaxSpeed[1]);
            // Move the cursor to the correct digit position
            cursor_position1[9 + selected_digit] = '^';
            cfa634_print("   ENTER MAX SPEED  ", 0, 0);
            cfa634_print("      VALUE 0-9     ", 0, 1);
            cfa634_print(display_value1, 0, 2);
            cfa634_print(cursor_position1, 0, 3);
            break;
        case 5:
            char display_value2[21];
            char cursor_position2[21] = "           ^         "; // Default cursor below second digit
            sprintf(display_value, "         %d%d         ", MinSpeed[0], MinSpeed[1]);
            // Move the cursor to the correct digit position
            cursor_position2[9 + selected_digit] = '^';
            cfa634_print("   ENTER MIN SPEED  ", 0, 0);
            cfa634_print("      VALUE 0-9     ", 0, 1);
            cfa634_print(display_value2, 0, 2);
            cfa634_print(cursor_position2, 0, 3);
            break;
        case 6:
            char display_value3[21];
            char cursor_position3[21] = "           ^         "; // Default cursor below second digit
            sprintf(display_value, "         %d%d         ", SpoolDiameter[0], SpoolDiameter[1]);
            // Move the cursor to the correct digit position
            cursor_position3[9 + selected_digit] = '^';
            cfa634_print("   ENTER Spool DI-  ", 0, 0);
            cfa634_print("   AMETER VALUE 0-9 ", 0, 1);
            cfa634_print(display_value3, 0, 2);
            cfa634_print(cursor_position3, 0, 3);
            break;
        case 7:
            cfa634_print(" RECALIBRATING DRAG ",0,0);
            cfa634_print("                    ",0,1);
            cfa634_print("  PUSH DIAL > RETURN",0,2);
            cfa634_print("                    ",0,3);
            break;
        case 8:
            cfa634_print("     BUZZER TEST    ",0,0);
            cfa634_print("    LEFT > ENABLE   ",0,1);
            cfa634_print("   RIGHT > DISABLE  ",0,2);
            cfa634_print(" PUSH DIAL > ENCODER",0,3);
            break;
        default: break;
    }
}
void settingsdisplay(int pos){
    switch (pos) {
        case 0:
            cfa634_print(" >0.RETURN          ",0,0);
            cfa634_print("  1.RESET LINE      ",0,1);
            cfa634_print("  2.AUTO STOP LENGTH",0,2);
            cfa634_print("  3.METRIC>IMPERIAL ",0,3);
            break;
        case 1:
            cfa634_print("  0.RETURN          ",0,0);
            cfa634_print(" >1.RESET LINE      ",0,1);
            cfa634_print("  2.AUTO STOP LENGTH",0,2);
            cfa634_print("  3.METRIC>IMPERIAL ",0,3);
            break;
        case 2:
            cfa634_print("  0.RETURN          ",0,0);
            cfa634_print("  1.RESET LINE      ",0,1);
            cfa634_print(" >2.AUTO STOP LENGTH",0,2);
            cfa634_print("  3.METRIC>IMPERIAL ",0,3);
            break;
        case 3:
            cfa634_print("  0.RETURN          ",0,0);
            cfa634_print("  1.RESET LINE      ",0,1);
            cfa634_print("  2.AUTO STOP LENGTH",0,2);
            cfa634_print(" >3.METRIC>IMPERIAL ",0,3);
            break;
        case 4:
            cfa634_print(" >4.MAX SPEED       ",0,0);
            cfa634_print("  5.MIN SPEED       ",0,1);
            cfa634_print("  6.SPOOL DIAMETER  ",0,2);
            cfa634_print("  7.RECALIBRATE DRAG",0,3);
            break;
        case 5:
            cfa634_print("  4.MAX SPEED       ",0,0);
            cfa634_print(" >5.MIN SPEED       ",0,1);
            cfa634_print("  6.SPOOL DIAMETER  ",0,2);
            cfa634_print("  7.RECALIBRATE DRAG",0,3);
            break;
        case 6:
            cfa634_print("  4.MAX SPEED       ",0,0);
            cfa634_print("  5.MIN SPEED       ",0,1);
            cfa634_print(" >6.SPOOL DIAMETER  ",0,2);
            cfa634_print("  7.RECALIBRATE DRAG",0,3);
            break;
        case 7:
            cfa634_print("  4.MAX SPEED       ",0,0);
            cfa634_print("  5.MIN SPEED       ",0,1);
            cfa634_print("  6.SPOOL DIAMETER  ",0,2);
            cfa634_print(" >7.RECALIBRATE DRAG",0,3);
            break;
        case 8:
            cfa634_print(" >8.BUZZER TEST     ",0,0);
            cfa634_print("                    ",0,1);
            cfa634_print("                    ",0,2);
            cfa634_print("                    ",0,3);
            break;
        default: break;
    }
}
void cfa634_main(int line, int drag) {
    cfa634_clear_screen();
    cfa634_print("   MAIN",0,0); // Line 1
    if(line < 10){ // Line 2
        char formattedline[20];
        sprintf(formattedline, "   LINE: 000%d FEET",line);
        cfa634_print(formattedline,0,1);
    } else if((line < 100)){
        char formattedline[20];
        sprintf(formattedline, "   LINE: 00%d FEET",line);
        cfa634_print(formattedline,0,1);
    } else if((line < 1000)){
        char formattedline[20];
        sprintf(formattedline, "   LINE: 0%d FEET",line);
        cfa634_print(formattedline,0,1);
    } else {
        char formattedline[20];
        sprintf(formattedline, "   LINE: %d FEET",line);
        cfa634_print(formattedline,0,1);
    }
    if(drag < 10){ // Line 3
        char formatteddrag[20];
        sprintf(formatteddrag, "   DRAG: 00%d FT-LBS",drag);
        cfa634_print(formatteddrag,0,1);
    } else  if (drag <100){
        char formatteddrag[20];
        sprintf(formatteddrag, "   DRAG: 0%d FT-LBS",drag);
        cfa634_print(formatteddrag,0,2);
    }
    else  {
        char formatteddrag[20];
        sprintf(formatteddrag, "   DRAG: %d FT-LBS",drag);
        cfa634_print(formatteddrag,0,2);
    }
    cfa634_print("  ",0,3); // Line 4
}

void handleunitselect() {
    if (!gpio_get(LBTN)) {
        isImperial = false;
        sleep_ms(50);
    }
    if (!gpio_get(RBTN)) {
        isImperial = true;
        sleep_ms(50);
    }
}
void read_btn() {
    if (menu_index == 2 || menu_index == 4 || menu_index == 5 || menu_index == 6) {
        if (!gpio_get(LBTN)) { // Left button pressed
            sleep_ms(100); // Debounce delay
            left_pressed = true;
            if (selected_digit > 0) { 
                selected_digit--; // Only decrement if not at the leftmost digit
            } else if (selected_digit < 0) {
                selected_digit == 0;
            }
        }
    
        if (!gpio_get(RBTN)) { // Right button pressed
            sleep_ms(100); // Debounce delay
            right_pressed = true;
            if (selected_digit < 1) { // Adjust for number of digits
                selected_digit++; // Only increment if not at the rightmost digit
            } else if (selected_digit > 1) {
                selected_digit == 1;
            }
        }
    }
    if (menu_index == 3) {
        if (!gpio_get(LBTN)) {
            left_pressed = true;
            isImperial = false;
            sleep_ms(50);
        }
        if (!gpio_get(RBTN)) {
            right_pressed = true;
            isImperial = true;
            sleep_ms(50);
        }
    }
    if (menu_index == 8) {
        if (!gpio_get(LBTN)) {
            left_pressed = true;
            buzz_en = true;
            gpio_put(Buzz, 1);
            sleep_ms(50);
        }
        if (!gpio_get(RBTN)) {
            right_pressed = true;
            buzz_en = false;
            gpio_put(Buzz, 0);
            sleep_ms(50);
        }
    }

    
}
void read_encoder(uint gpio, uint32_t events) {
    // Read encoder channels A and B from the GPIO state.
    uint32_t gpio_state = (gpio_get_all() >> 10) & 0b11;

    if (!in_submenu) {
        // In settings menu mode.
        if (gpio == ENCODER_A) {
            if (!cw_fall && (gpio_state == 0b10)) {
                cw_fall = true;
            }
            if (ccw_fall && (gpio_state == 0b00)) {  // Counter-clockwise detected.
                ccw_fall = false;
                cw_fall = false;
                menu_index--;
                if (menu_index < 0) menu_index = 0;
                printf("[ENCODER] CCW - Menu index: %d\n", menu_index);
            }
        } else if (gpio == ENCODER_B) {
            if (!ccw_fall && (gpio_state == 0b01)) {
                ccw_fall = true;
            }
            if (cw_fall && (gpio_state == 0b00)) {  // Clockwise detected.
                cw_fall = false;
                ccw_fall = false;
                menu_index++;
                if (menu_index > 8) menu_index = 8;
                printf("[ENCODER] CW - Menu index: %d\n", menu_index);
            }
        }
    } else {
        // In subpage mode: For numeric subpages (0 and 1), encoder rotations adjust the parameter.
        if (menu_index == 2 || menu_index == 4 || menu_index == 5 || menu_index == 6) {
            if (gpio == ENCODER_A) {
                if (!cw_fall && (gpio_state == 0b10)) {
                    cw_fall = true;
                }
                if (ccw_fall && (gpio_state == 0b00)) {
                    ccw_fall = false;
                    cw_fall = false;
                    if (menu_index == 2) {
                        AutoStopLen[selected_digit] -= 1;
                        if (AutoStopLen[selected_digit] < 0) AutoStopLen[selected_digit] = 0;
                    }
                    if (menu_index == 4) {
                        MaxSpeed[selected_digit] -= 1;
                        if (MaxSpeed[selected_digit] < 0) MaxSpeed[selected_digit] = 0;
                    }
                    if (menu_index == 5) {
                        MinSpeed[selected_digit] -= 1;
                        if (MinSpeed[selected_digit] < 0) MinSpeed[selected_digit] = 0;
                    }
                    if (menu_index == 6) {
                        SpoolDiameter[selected_digit] -= 1;
                        if (SpoolDiameter[selected_digit] < 0) SpoolDiameter[selected_digit] = 0;
                    }
                }
               
            } else if (gpio == ENCODER_B) {
                if (!cw_fall && (gpio_state == 0b10)) {
                    cw_fall = true;
                }
                if (ccw_fall && (gpio_state == 0b00)) {
                    ccw_fall = false;
                    cw_fall = false;
                    if (menu_index == 2) {
                        AutoStopLen[selected_digit] += 1;
                        if (AutoStopLen[selected_digit] > 9) AutoStopLen[selected_digit] = 9;
                    }
                    if (menu_index == 4) {
                        MaxSpeed[selected_digit] += 1;
                        if (MaxSpeed[selected_digit] > 9) MaxSpeed[selected_digit] = 9;
                    }
                    if (menu_index == 5) {
                        MinSpeed[selected_digit] += 1;
                        if (MinSpeed[selected_digit] > 9) MinSpeed[selected_digit] = 9;
                    }
                    if (menu_index == 6) {
                        SpoolDiameter[selected_digit] += 1;
                        if (SpoolDiameter[selected_digit] > 9) SpoolDiameter[selected_digit] = 9;
                    }
                }
            }
        }
        // For other subpages (toggles and Save), encoder rotations are not used.
    }
}
void check_encoder() {
    if (!in_settings_menu && !gpio_get(ENCODER_BTN)) { // Button active low.
        if (!button_pressed) {
            button_pressed = true;
            button_press_time = to_ms_since_boot(get_absolute_time());
        } else if (to_ms_since_boot(get_absolute_time()) - button_press_time > 3000) {
            in_settings_menu = true;
            menu_index = 0;
            settingsdisplay(menu_index);
            last_menu_index = menu_index;
            ignore_next_press = true; // Ignore the next press to prevent immediate selection.
        }
    } else if (gpio_get(ENCODER_BTN)) {
        button_pressed = false;
    }
    if (in_settings_menu) {
        if (!in_submenu && !gpio_get(ENCODER_BTN)) {  // Enter submenu on short press of SELECT button
            if (!button_pressed) {
                button_pressed = true;
                button_press_time = to_ms_since_boot(get_absolute_time());
            } else if (to_ms_since_boot(get_absolute_time()) - button_press_time < 1000) {  // Short press (<1s)
                in_submenu = true;
                menu_index = selected_menu;  // Set the menu index to the selected submenu
                printf("[SETTINGS] Entering submenu: %d\n", menu_index);
            }
        } else if (gpio_get(ENCODER_BTN)) {
            button_pressed = false; // Reset button press when the button is released
        }

        // Check for back button press to exit submenu
        if (in_submenu && !gpio_get(ENCODER_BTN)) {  // Exit submenu on short press of BACK button
            if (!button_pressed) {
                button_pressed = true;
                button_press_time = to_ms_since_boot(get_absolute_time());
            } else if (to_ms_since_boot(get_absolute_time()) - button_press_time < 1000) {  // Short press (<1s)
                in_submenu = false;
            }
        } else if (gpio_get(ENCODER_BTN)) {
            button_pressed = false; // Reset button press when the button is released
        }
    }
}
void gpio_setup() {
    // Encoder Reading
    gpio_init(ENCODER_A);
    gpio_set_dir(ENCODER_A, GPIO_IN);
    gpio_pull_up(ENCODER_A);
    gpio_init(ENCODER_B);
    gpio_set_dir(ENCODER_B, GPIO_IN);
    gpio_pull_up(ENCODER_B);
    gpio_init(ENCODER_BTN);
    gpio_set_dir(ENCODER_BTN, GPIO_IN);
    gpio_pull_down(ENCODER_BTN);
    gpio_set_irq_enabled_with_callback(ENCODER_A, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &read_encoder);
    gpio_set_irq_enabled_with_callback(ENCODER_B, GPIO_IRQ_EDGE_RISE | GPIO_IRQ_EDGE_FALL, true, &read_encoder);
    // Button Reading Left Then Right
    gpio_init(LBTN);
    gpio_set_dir(LBTN, GPIO_IN);
    gpio_pull_down(LBTN);
    gpio_init(RBTN);
    gpio_set_dir(RBTN, GPIO_IN);
    gpio_pull_down(RBTN);
    gpio_set_irq_enabled_with_callback(LBTN, GPIO_IRQ_EDGE_RISE,true, &read_btn);
    gpio_set_irq_enabled_with_callback(RBTN, GPIO_IRQ_EDGE_RISE,true, &read_btn);
    // Buzzer Init
    gpio_init(Buzz);
    gpio_set_dir(Buzz, GPIO_OUT);
    gpio_put(Buzz, 1);
}
int main() {
    stdio_init_all();
    i2c_setup();
    gpio_setup();
    sleep_ms(500); // Wait for LCD to power up
    cfa634_clear_screen();
    int linelength = 0;
    int dragset = 0;
    cfa634_main(linelength, dragset);
    while (1) {
        if (!in_settings_menu) {
            check_encoder();
        }
        // In settings mode: if in a subpage, check for exit, otherwise check for subpage entry.
        if (in_settings_menu) {
            if (in_submenu) {
                check_encoder();
                if (menuActive) {
                    selectedmenudisplay(menu_index);
                }
            } else {
                check_encoder();
                if (menu_index != last_menu_index) {
                    settingsdisplay(menu_index);
                    last_menu_index = menu_index;
                }
            }
        }
        sleep_ms(100);
    }
}
